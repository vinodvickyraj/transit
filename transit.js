/**
 * Transit makes it simple to perform AJAX requests by using event attributes directly in your HTML. 
 * This allows you to create modern, interactive user interfaces with little effort, 
 * combining the simplicity of HTML with the power of AJAX.
 * 
 * version 1.0
 */
class Transit {
    /**
     * Constructor initializes the library instance with the root element.
     * @param {HTMLElement} rootElement - The root DOM element where the library functionalities attach.
     */
    constructor(rootElement) {
        // Retrieve the base URL and CSRF token for secure requests from meta tags
        this.baseUrl = document.querySelector('meta[name="base-url"]')?.getAttribute('content') || '';
        this.csrfToken = document.querySelector('meta[name="csrf-token"]')?.getAttribute('content') || '';

        // Set default headers for requests
        this.headers = { 'X-CSRF-Token': this.csrfToken };

        // Initialize hook management system for extensibility
        this.hooks = new this.HookManager();

        // Setup event listeners on all elements inside the rootElement
        this.initEventListeners(rootElement);

        // Trigger load events if there are any
        this.triggerLoadEvents(rootElement);

        // Dispatch a custom event indicating that Transit has been successfully initialized
        document.dispatchEvent(new CustomEvent('TransitInitialized', { detail: { instance: this } }));
    }

    /**
     * Initializes event listeners for various events such as load, submit, click, etc.
     * @param {HTMLElement} scope - The DOM container within which to search for elements.
     */
    initEventListeners(scope) {
        const defaultEvents = ['load', 'submit', 'change', 'click', 'dblclick', 'blur', 'focus', 'focusin', 'focusout', 'keydown', 'keypress', 'keyup'];
        
        // Allow hooks to modify the event types
        const supportedEvents = this.hooks.applyFilters('modifyEvents', defaultEvents, scope);

        // Attach listeners to elements with `on-*` attributes
        supportedEvents.forEach(eventType => {
            scope.querySelectorAll(`[on-${eventType}]`).forEach(element => {
                element.addEventListener(eventType, this.handleEvent.bind(this));
            });
        });

        // Dispatch a custom event indicating Transit is ready
        document.dispatchEvent(new CustomEvent('TransitReady', { detail: { scope } }));
    }

    /**
     * Triggers 'load' events on elements that have an `on-load` attribute.
     * @param {HTMLElement} scope - The DOM container where load events should be triggered.
     */
    triggerLoadEvents(scope) {
        scope.querySelectorAll('[on-load]').forEach(element => {
            element.dispatchEvent(new Event('load')); // Manually trigger 'load' event
        });
    }

    /**
     * Generic event handler that processes events and sends requests if needed.
     * @param {Event} event - The event object generated by the user interaction.
     */
    async handleEvent(event) {
        event.preventDefault(); // Prevent default browser behavior

        const element = event.target.closest(`[on-${event.type}]`);
        if (!element || element.classList.contains('processing')) return;  // Prevent if element is already processing

        // Execute all hooks associated with 'beforeRequest'
        const shouldProceed = await this.hooks.doAction('beforeRequest', element, event);

        if (shouldProceed !== false) {
            this.processEvent(element, event); // Process event only if no hook stops it
        }
    }

    /**
     * Processes the event by determining the URL, method, and sending the request.
     * @param {HTMLElement} element - The element that triggered the event.
     * @param {Event} event - The event object.
     */
    processEvent(element, event) {
        const url = element.getAttribute(`on-${event.type}`);
        const method = element.getAttribute('method') || 'POST';

        if (url) {
            this.toggleProcessingState(element, true);
            this.sendRequest(url, element, method)
                .then(responseData => this.handleResponse(element, responseData))
                .catch(error => {
                    console.error('An error occurred:', error);
                    this.toggleProcessingState(element, false);
                });
        }
    }


    /**
     * Toggles a 'processing' state on the element and any linked elements (via 'map' attribute).
     * It also disables the element to prevent further interactions.
     * @param {HTMLElement} element - The element being processed.
     * @param {boolean} isProcessing - Whether the element is in a processing state.
     */
    toggleProcessingState(element, isProcessing) {
        element.classList.toggle('processing', isProcessing);

        if (element.tagName === 'FORM') {
            element.querySelectorAll('[type="submit"]').forEach(button => button.disabled = isProcessing);
        }

        const mappedElement = document.querySelector(`[map="${element.getAttribute('key')}"]`);
        if (mappedElement) mappedElement.classList.toggle('processing', isProcessing);
    }
 

    /**
     * Sends an HTTP request based on the element's attributes and specified method.
     * Handles form data, JSON, and file uploads.
     * @param {string} url - The URL to which the request is sent.
     * @param {HTMLElement} element - The element triggering the request.
     * @param {string} method - The HTTP method (e.g., POST, GET).
     * @returns {Promise<Object>} - The server response as a JSON object.
     */
    sendRequest(url, element, method) {
        return this.collectDataAttributes(element).then(data => {
            const options = {
                method: method.toUpperCase(),
                headers: { ...this.headers },
                cache: 'no-cache',
            };

            if (options.method === 'GET') {
                // Handle GET requests by appending data to the URL as query parameters
                const queryString = new URLSearchParams(data).toString();
                url = queryString ? `${url}?${queryString}` : url;
            } else if (options.method === 'POST') {
                // Handle POST requests by sending data in the body
                if (data instanceof FormData) {
                    // For file uploads or forms with FormData
                    options.body = data;
                    delete options.headers['Content-Type']; // Let the browser set the content type for FormData
                } else {
                    // For regular form submissions (non-file uploads), use x-www-form-urlencoded
                    options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
                    options.body = new URLSearchParams(data).toString();
                }
            } else {
                throw new Error('Unsupported method. Only GET and POST are allowed.');
            }

            return fetch(this.baseUrl + url, options)
                .then(response => {
                    // Check if the response has content or is expected to be JSON
                    const contentType = response.headers.get('content-type');
                    if (response.ok && contentType && contentType.includes('application/json')) {
                        return response.json(); // Parse response as JSON if content-type is JSON
                    } else if (response.ok && contentType && contentType.includes('text/html')) {
                        return response.text(); // Handle plain text or HTML responses
                    } else if (response.ok && response.status === 204) {
                        return {}; // Handle empty responses (e.g., HTTP 204 No Content)
                    } else {
                        throw new Error('Unexpected response format');
                    }
                })
                .catch(error => {
                    console.error('An error occurred:', error);
                    throw error;
                });
        });
    }

    /**
     * Collects data from form elements or individual input elements, handling files, checkboxes, etc.
     * All data is sent as FormData to ensure consistent behavior.
     * @param {HTMLElement} element - The element from which to collect data.
     * @returns {Promise<FormData>} - A promise resolving with the collected FormData.
     */
    collectDataAttributes(element) {
        const formData = new FormData();

        if (element.tagName === 'FORM') {
            // If it's a form element, append all form fields to FormData
            return Promise.resolve(new FormData(element));
        }

        if (element.matches('input, select, textarea')) {
            const key = element.name || element.id;
            if (key) {
                switch (element.type) {
                    case 'checkbox':
                        formData.append(key, element.checked ? '1' : '0'); // Append checkbox value as '1' for true, '0' for false
                        break;
                    case 'radio':
                        if (element.checked) {
                            formData.append(key, element.value); // Append radio value only if checked
                        }
                        break;
                    case 'file':
                        if (element.files.length > 0) {
                            formData.append(key, element.files[0]); // Append the first file
                        }
                        break;
                    default:
                        formData.append(key, element.value); // Append value for other input types
                }
            }
        }

        // Append any `data-*` attributes as form fields
        element.getAttributeNames().forEach(attr => {
            if (attr.startsWith('data-')) {
                formData.append(attr.slice(5), element.getAttribute(attr)); // Remove 'data-' prefix
            }
        });

        return Promise.resolve(formData);
    }


    /**
     * Reads a file input as binary data. Used for file uploads.
     * @param {File} file - The file object.
     * @returns {Promise<ArrayBuffer>} - A promise that resolves with the file's binary content.
     */
    readFileAsBinary(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsArrayBuffer(file);
        });
    }

    /**
     * Handles the server response and executes any actions defined in the response data.
     * @param {HTMLElement} element - The element that initiated the request.
     * @param {Object} responseData - The response data from the server.
     */
    handleResponse(element, responseData) {
        const actions = Array.isArray(responseData) ? responseData : [responseData];
        actions.forEach(action => this.processAction(element, action));
        this.toggleProcessingState(element, false);
    }

    /**
     * Executes actions based on the response data. Can modify the DOM, navigate, show alerts, etc.
     * @param {HTMLElement} element - The element that initiated the request.
     * @param {Object} action - The action object containing instructions (e.g., update HTML, redirect, etc.).
     */
    processAction(element, action) {
        action = this.hooks.applyFilters('modifyAction', action, element);

        if (action.fn) {
            const { name, arguments: args = [] } = action.fn;
            const func = window[name];
            if (typeof func === 'function') {
                try {
                    func(...args);
                } catch (error) {
                    console.error(`Error executing function ${name}:`, error);
                }
            } else {
                console.error(`Function ${name} is not defined`);
            }
        }

        if (action.document) {
            this.updateDOM(action.document);
        }

        this.hooks.doAction('afterResponse', element, action);

        if (action.redirect) window.location.href = action.redirect;
        if (action.reload) location.reload();
    }

    /**
     * Updates the DOM based on the provided action data.
     * This method handles various DOM manipulation tasks such as updating innerHTML,
     * appending content, adding/removing classes, resetting forms, etc.
     * @param {Object|Array} documentActions - The actions that define how the DOM should be updated.
     */
    updateDOM(documentActions) {
        const actions = Array.isArray(documentActions) ? documentActions : [documentActions];
        actions.forEach(action => {
            const elements = document.querySelectorAll(action.element || action.selector);
            if (!elements.length) return;

            elements.forEach(element => {
                switch (action.method) {
                    case 'html':
                        element.innerHTML = action.value; // Update inner HTML
                        this.initEventListeners(element); // Re-initialize event listeners for new content
                        break;
                    case 'append':
                        element.insertAdjacentHTML('beforeend', action.value); // Append HTML
                        this.initEventListeners(element.lastElementChild); // Re-initialize event listeners
                        break;
                    case 'prepend':
                        element.insertAdjacentHTML('afterbegin', action.value); // Prepend HTML
                        this.initEventListeners(element.firstElementChild); // Re-initialize event listeners
                        break;
                    case 'addClass':
                        element.classList.add(action.value); // Add CSS class
                        break;
                    case 'removeClass':
                        element.classList.remove(action.value); // Remove CSS class
                        break;
                    case 'attr':
                        element.setAttribute(action.value[0], action.value[1]); // Set an attribute
                        break;
                    case 'removeAttr':
                        element.removeAttribute(action.value); // Remove an attribute
                        break;
                    case 'remove':
                        element.remove(); // Remove element from DOM
                        break;
                    case 'reset':
                        if (element.tagName === 'FORM') {
                            element.reset(); // Reset form fields
                        }
                        break;
                    default:
                        console.error('Unsupported DOM method:', action.method);
                }
            });
        });
    }


    /**
     * A class that manages hooks for actions and filters within Transit.
     * It allows developers to extend or modify the functionality of Transit.
     */
    HookManager = class {
        constructor() {
            this.actions = {};
            this.filters = {};
        }

        /**
         * Registers an action hook. Actions are executed at specific points within the library.
         * @param {string} hook - The name of the action hook.
         * @param {Function} callback - The callback function to execute.
         * @param {number} [priority=10] - The priority of the action (lower number means higher priority).
         */
        addAction(hook, callback, priority = 10) {
            if (!this.actions[hook]) this.actions[hook] = [];
            this.actions[hook].push({ callback, priority });
            this.actions[hook].sort((a, b) => a.priority - b.priority);
        }

        /**
         * Registers a filter hook. Filters modify data at specific points within the library.
         * @param {string} hook - The name of the filter hook.
         * @param {Function} callback - The callback function to apply.
         * @param {number} [priority=10] - The priority of the filter (lower number means higher priority).
         */
        addFilter(hook, callback, priority = 10) {
            if (!this.filters[hook]) this.filters[hook] = [];
            this.filters[hook].push({ callback, priority });
            this.filters[hook].sort((a, b) => a.priority - b.priority);
        }

        /**
         * Executes all registered action hooks for a given hook name.
         * If any action hook returns `false`, subsequent hooks will not be executed.
         * @param {string} hook - The name of the action hook.
         * @param {...any} args - Arguments to pass to the action callbacks.
         * @returns {Promise<boolean>} - Resolves to `true` if all actions allow proceeding, or `false` if any action stops the process.
         */
        async doAction(hook, ...args) {
            if (this.actions[hook]) {
                for (let action of this.actions[hook]) {
                    const result = await action.callback(...args);
                    if (result === false) return false;
                }
            }
            return true;
        }

        /**
         * Applies all registered filter hooks for a given hook name, modifying the passed value.
         * @param {string} hook - The name of the filter hook.
         * @param {any} value - The initial value to be filtered.
         * @param {...any} args - Additional arguments to pass to the filter callbacks.
         * @returns {any} - The modified value after all filters are applied.
         */
        applyFilters(hook, value, ...args) {
            if (this.filters[hook]) {
                this.filters[hook].forEach(filter => {
                    value = filter.callback(value, ...args);
                });
            }
            return value;
        }
    };
}

// Initialize Transit when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', () => {
    new Transit(document);
});